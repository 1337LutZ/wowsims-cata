package main

import (
	"fmt"
	"log"
	"os"
	"strings"

	"github.com/wowsims/wotlk/sim/core/proto"
	"github.com/wowsims/wotlk/sim/core/stats"
	protojson "google.golang.org/protobuf/encoding/protojson"
	googleProto "google.golang.org/protobuf/proto"
)

func writeItemFile(outDir string, itemsData []ItemData) {
	err := os.MkdirAll(outDir, os.ModePerm)
	if err != nil {
		panic(err)
	}

	file, err := os.Create(fmt.Sprintf("%s/all_items.go", outDir))
	if err != nil {
		panic(err)
	}
	defer file.Close()

	file.WriteString(`// DO NOT EDIT. This file is auto-generated by the item generator tool. Use that to make edits.
	
package items
	
import (
	"github.com/wowsims/wotlk/sim/core/proto"
	"github.com/wowsims/wotlk/sim/core/stats"
)

var Items = []Item{
`)

	for _, itemData := range itemsData {
		file.WriteString(fmt.Sprintf("\t%s,\n", itemToGoString(itemData)))
	}

	file.WriteString("}\n")

	file.Sync()
}

func writeGemFile(outDir string, gemsData []GemData) {
	err := os.MkdirAll(outDir, os.ModePerm)
	if err != nil {
		panic(err)
	}

	file, err := os.Create(fmt.Sprintf("%s/all_gems.go", outDir))
	if err != nil {
		panic(err)
	}
	defer file.Close()

	file.WriteString(`// DO NOT EDIT. This file is auto-generated by the item generator tool. Use that to make edits.
	
package items
	
import (
	"github.com/wowsims/wotlk/sim/core/proto"
	"github.com/wowsims/wotlk/sim/core/stats"
)

var Gems = []Gem{
`)

	for _, gemData := range gemsData {
		file.WriteString(fmt.Sprintf("\t%s,\n", gemToGoString(gemData.Override, gemData.Response)))
	}

	file.WriteString("}\n")

	file.Sync()
}

func writeDatabaseFile(db *WowDatabase) {
	uiDB := db.toUIDatabase()

	// Write database as a binary file.
	outbytes, err := googleProto.Marshal(uiDB)
	if err != nil {
		log.Fatalf("[ERROR] Failed to marshal db: %s", err.Error())
	}
	os.WriteFile("./assets/database/db.bin", outbytes, 0666)

	// Also write in JSON format so we can manually inspect the contents.
	// Write it out line-by-line so we can have 1 line / item, making it more human-readable.
	builder := &strings.Builder{}
	builder.WriteString("{\n")

	builder.WriteString("\"itemIcons\":[\n")
	for i, icon := range uiDB.ItemIcons {
		json, err := protojson.MarshalOptions{}.Marshal(icon)
		if err != nil {
			log.Printf("[ERROR] Failed to marshal icon: %s", err.Error())
		}
		builder.WriteString(string(json))
		if i != len(uiDB.ItemIcons)-1 {
			builder.WriteString(",\n")
		}
	}
	builder.WriteString("],\n")

	builder.WriteString("\"spellIcons\":[\n")
	for i, icon := range uiDB.SpellIcons {
		json, err := protojson.MarshalOptions{}.Marshal(icon)
		if err != nil {
			log.Printf("[ERROR] Failed to marshal icon: %s", err.Error())
		}
		builder.WriteString(string(json))
		if i != len(uiDB.SpellIcons)-1 {
			builder.WriteString(",\n")
		}
	}
	builder.WriteString("]\n")

	builder.WriteString("}")
	os.WriteFile("./assets/database/db.json", []byte(builder.String()), 0666)
}

func gemToGoString(gemOverride GemOverride, gemResponse ItemResponse) string {
	gemStr := "{"

	gemStr += fmt.Sprintf("Name:\"%s\", ", gemResponse.GetName())
	gemStr += fmt.Sprintf("ID:%d, ", gemOverride.ID)

	phase := gemOverride.Phase
	if phase == 0 {
		phase = gemResponse.GetPhase()
	}
	gemStr += fmt.Sprintf("Phase:%d, ", phase)
	gemStr += fmt.Sprintf("Quality:proto.ItemQuality_%s, ", proto.ItemQuality(gemResponse.GetQuality()).String())
	gemStr += fmt.Sprintf("Color:proto.GemColor_%s, ", gemResponse.GetSocketColor().String())
	gemStr += fmt.Sprintf("Stats: %s, ", statsToGoString(gemResponse.GetGemStats(), gemOverride.Stats))

	if gemResponse.GetUnique() {
		gemStr += "Unique:true, "
	}

	prof := gemResponse.GetRequiredProfession()
	if prof != proto.Profession_ProfessionUnknown {
		gemStr += fmt.Sprintf("RequiredProfession:proto.Profession_%s, ", prof.String())
	}

	gemStr += "}"
	return gemStr
}

func itemToGoString(itemData ItemData) string {
	itemStr := "{"

	itemStr += fmt.Sprintf("Name:\"%s\", ", strings.ReplaceAll(itemData.Response.GetName(), "\"", "\\\""))
	itemStr += fmt.Sprintf("ID:%d, ", itemData.Override.ID)

	classAllowlist := itemData.Response.GetClassAllowlist()
	if len(itemData.Override.ClassAllowlist) > 0 {
		classAllowlist = itemData.Override.ClassAllowlist
	}
	if len(classAllowlist) > 0 {
		itemStr += "ClassAllowlist: []proto.Class{"
		for _, class := range classAllowlist {
			itemStr += fmt.Sprintf("proto.Class_%s,", class.String())
		}
		itemStr += "}, "
	}

	itemStr += fmt.Sprintf("Type:proto.ItemType_%s, ", itemData.Response.GetItemType().String())

	armorType := itemData.Response.GetArmorType()
	if armorType != proto.ArmorType_ArmorTypeUnknown {
		itemStr += fmt.Sprintf("ArmorType:proto.ArmorType_%s, ", armorType.String())
	}

	weaponType := itemData.Response.GetWeaponType()
	if weaponType != proto.WeaponType_WeaponTypeUnknown {
		itemStr += fmt.Sprintf("WeaponType:proto.WeaponType_%s, ", weaponType.String())

		handType := itemData.Response.GetHandType()
		if itemData.Override.HandType != proto.HandType_HandTypeUnknown {
			handType = itemData.Override.HandType
		}
		if handType == proto.HandType_HandTypeUnknown {
			panic("Unknown hand type for item: " + fmt.Sprintf("%#v", itemData.Response))
		}
		itemStr += fmt.Sprintf("HandType:proto.HandType_%s, ", handType.String())
	} else {
		rangedWeaponType := itemData.Response.GetRangedWeaponType()
		if rangedWeaponType != proto.RangedWeaponType_RangedWeaponTypeUnknown {
			itemStr += fmt.Sprintf("RangedWeaponType:proto.RangedWeaponType_%s, ", rangedWeaponType.String())
		}
	}

	min, max := itemData.Response.GetWeaponDamage()
	if min != 0 && max != 0 {
		itemStr += fmt.Sprintf("WeaponDamageMin: %0.1f, ", min)
		itemStr += fmt.Sprintf("WeaponDamageMax: %0.1f, ", max)
	}
	speed := itemData.Response.GetWeaponSpeed()
	if speed != 0 {
		itemStr += fmt.Sprintf("SwingSpeed: %0.2f, ", speed)
	}

	phase := itemData.Override.Phase
	if phase == 0 {
		phase = itemData.Response.GetPhase()
	}
	itemStr += fmt.Sprintf("Phase:%d, ", phase)
	itemStr += fmt.Sprintf("Quality:proto.ItemQuality_%s, ", proto.ItemQuality(itemData.Response.GetQuality()).String())

	if itemData.Response.GetUnique() {
		itemStr += "Unique:true, "
	}

	itemStr += fmt.Sprintf("Ilvl:%d, ", itemData.Response.GetItemLevel())
	itemStr += fmt.Sprintf("Stats: %s", statsToGoString(itemData.Response.GetStats(), itemData.Override.Stats))

	gemSockets := itemData.Response.GetGemSockets()
	if len(gemSockets) > 0 {
		itemStr += ", GemSockets: []proto.GemColor{"
		for _, gemColor := range gemSockets {
			itemStr += fmt.Sprintf("proto.GemColor_%s,", gemColor.String())
		}
		itemStr += "}, "
		itemStr += fmt.Sprintf("SocketBonus: %s", statsToGoString(itemData.Response.GetSocketBonus(), Stats{}))
	}

	setName := itemData.Response.GetItemSetName()
	if setName != "" {
		itemStr += fmt.Sprintf(", SetName: \"%s\"", setName)
	}

	prof := itemData.Response.GetRequiredProfession()
	if prof != proto.Profession_ProfessionUnknown {
		itemStr += fmt.Sprintf(", RequiredProfession:proto.Profession_%s", prof.String())
	}

	if itemData.Response.IsHeroic() {
		itemStr += ", Heroic: true"
	}

	itemStr += "}"
	return itemStr
}

func statsToGoString(statlist Stats, overrides Stats) string {
	statsStr := "stats.Stats{"

	for stat, value := range statlist {
		val := value
		if overrides[stat] > 0 {
			val = overrides[stat]
		}
		if value > 0 {
			statsStr += fmt.Sprintf("stats.%s:%.0f,", stats.Stat(stat).StatName(), val)
		}
	}

	statsStr += "}"
	return statsStr
}
